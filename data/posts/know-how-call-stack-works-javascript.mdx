Para aprender como funciona Javascript existen m煤ltiples conceptos que son claves, que nos ayudan a entender como es
[interpretado](https://es.wikipedia.org/wiki/Int%C3%A9rprete_de_JavaScript) nuestro c贸digo, en que orden es ejecutado y
como podemos buscar errores m谩s f谩cilmente. Call Stack es un importante concepto que aparece de primero en la lista del
famoso repositorio ["33 Concepts Every JavaScript Developer Should Know"](https://github.com/leonardomso/33-js-concepts#1-call-stack)
que invito a que revises despu茅s de terminar de ver este post.

## Stack o Pila

Para continuar primero vamos a entender que es una pila o stack. Este es un algoritmo conocido por sus siglas
[LIFO](https://es.wikipedia.org/wiki/Last_in,_first_out) que significa **Last in, First Out**, que en espa帽ol es
el 煤ltimo en entrar, es el primero en salir. Un ejemplo para entender mejor el concepto es cuando pensamos en varios
libros uno sobre otro,  a esto lo llamamos una pila de libros, si queremos poner un nuevo libro, lo hacemos
poni茅ndolo encima de los que ya tenemos y si queremos obtener el libro del medio, debemos ir quitando los 煤ltimos
libros que pusimos que son los de arriba hasta llegar al que queremos.

<img src="https://media.giphy.com/media/KDYB0cH4HW8xc3VIAx/giphy.gif" alt="books stack" loading="lazy" />

## Entonces que es el Call Stack

En espa帽ol es conocido como [Pila de llamadas](https://developer.mozilla.org/es/docs/Glossary/Call_stack), este es usado
por Javascript para saber en qu茅 funci贸n se encuentra el punto de ejecuci贸n y por cu谩les otras funciones a pasado para
llegar a este punto, Javascript va apilando en el call stack cada funci贸n por la que pasa para saber luego por cu谩les
funciones debe devolverse despu茅s de terminar la ejecuci贸n de cada una de estas. Miremos como funciona con un ejemplo.

<CallStack
  code={`function above() {\n  return middle()\n}\n\nfunction middle() {\n  return below()\n}\n\nfunction below() {\n  return 1\n}\n\nabove()\n`}
  stack={[
    { name: '(anonymous)', line: 13 },
    { name: 'above()', line: 2 },
    { name: 'middle()', line: 6 },
    { name: 'below()', line: 10 }
  ]}
  steps={[
    { stack: [0], line: 13, description: 'En la l铆nea 13 comenzamos nuestra ejecuci贸n, esta funci贸n inicial es llamada como (anonymous), es la funci贸n principal de la ejecuci贸n, cuando esta funci贸n no exista es porque hemos terminado la ejecuci贸n.' },
    { stack: [0, 1], line: 2, description: 'Ingresamos a la funci贸n llamada en la l铆nea 13, above() y es apilada en el call stack, tambi茅n podemos ver que avanzamos a la l铆nea 2 del c贸digo.' },
    { stack: [0, 1, 2], line: 6, description: 'Como middle() fue llamada en la l铆nea 2 al avanzar en la ejecuci贸n ingresamos a esta funci贸n y es apilada en el call stack.' },
    { stack: [0, 1, 2, 3], line: 10, description: 'Igual que el paso anterior below() es llamada y al avanzar ingresamos en ella y es apilada.' },
    { stack: [0, 1, 2, 3], line: 10, description: 'below() es nuestra 煤ltima funcio, en la l铆nea 10 tenemos un return que nos indica la finalizaci贸n de la funci贸n.' },
    { stack: [0, 1, 2], line: 6, description: 'Retornamos a la l铆nea 6 y se elimina del call stack la funci贸n below(). 驴C贸mo sab铆a Javascript que pod铆a retornar a la funci贸n middle()? Al desapilar below() la siguiente funci贸n en la pila era middle() con referencia a la l铆nea 6 y as铆 Javascript usa el call stack para saber donde debe continuar la ejecuci贸n.' },
    { stack: [0, 1], line: 2, description: 'Igual que en el paso anterior al continuar la ejecuci贸n se quita de la pila la funci贸n middle() y seguimos en la funci贸n above() donde encontramos otro return.' },
    { stack: [0], line: 13, description: 'En el paso anterior al encontrar el return y continuar la ejecuci贸n se remueve la funci贸n above() de la pila y volvemos a la funci贸n (anonymous) en la l铆nea 13 donde comenz贸 la ejecuci贸n con nuestro valor retornado 1.' },
    { stack: [], line: 14, description: 'Seguimos a la l铆nea 14 donde nuestro programa termina y es removida la funci贸n (anonymous)' }
  ]}
/>

> En el Call Stack aparte del nombre de la funci贸n y n煤mero de la l铆nea, se guarda tambi茅n el nombre del archivo donde
se encuentra y su contexto actual de ejecuci贸n o como es conocido por su nombre en ingl茅s [Scope](https://developer.mozilla.org/es/docs/Glossary/Scope),
que son las variables a las cuales podemos acceder, es decir, que son "visibles" para una funci贸n.

## 驴Por qu茅 es importante conocer el Call Stack?

* Nos ayuda a entender como funciona el debbuger y poder encontrar mucho m谩s r谩pido los bugs del proyecto.
* Nos ayuda a entender como funciona Javascript y por ende al pensar en construir nuestro c贸digo lo haremos mucho m谩s r谩pido y
concientes.
* En las entrevistas suelen preguntas por estos conceptos de Javascript.

No solo es importante conocer el Call Stask sino tambi茅n cada uno de esos conceptos claves o formas en la que funciona
Javascript para entender cada vez m谩s este lenguaje que usamos casi a diario en nuestros proyectos.

## 驴Y que m谩s podemos aprender del Call Stack?

### Maximum call stack size exceeded

Si te has encontrado con este mensaje de error **Uncaught RangeError: Maximum call stack size exceeded** en la consola
de las herramientas del desarrollador del navegador se debe a que el call stack tiene un l铆mite que depende del
navegador, puedes ver un poco m谩s de este l铆mite en el post [The maximum call stack size](https://2ality.com/2014/04/call-stack-size.html).

```javascript
function above() {
  return above()
}

above()
```
Este c贸digo es un ejemplo b谩sico de como podemos exceder el l铆mite del call stack a prop贸sito y verlo en consola de las
herramientas del desarrollador de nuestro browser, este error casi siempre se ocasiona al implementar un llamado
[recursivo](https://es.wikipedia.org/wiki/Recursi%C3%B3n) de una funci贸n, es dif铆cil exponer una soluci贸n espec铆fica
para cuando te aparezca este mensaje error, pero es de gran ayuda revisar que nuestro c贸digo si est谩 relacionado con
recursi贸n asegurarnos de que haya un caso donde no se contin煤e llamando m谩s la misma funci贸n y la ejecuci贸n pueda terminar.

### 驴C贸mo hacemos seguimiento del call stack de nuestro c贸digo?

Para esto podemos usar dentro de una funci贸n que queramos saber por donde ha pasado la ejecuci贸n hasta llegar hasta
la l铆nea que deseemos podemos usar la funci贸n `console.trace()`, esta funci贸n nos mostrar谩 el estado actual del nuestro
call stack.
```javascript
function above() {
  return below()
}

function below() {
  console.trace()
}

above()
```
```console
below	@	VM4271:6
above	@	VM4271:2
(anonymous)	@	VM4271:9
```
Tambi茅n tenemos las herramientas de desarrollador del navegador, por ejemplo en Chrome podemos acceder con la tecla
`F12` en Window y `OPT + CMD + i` en Mac, en la secci贸n de `source` podemos agregar un breakpoint, en el post
[Pause your code with breakpoints](https://developer.chrome.com/docs/devtools/javascript/breakpoints/) puedes aprender
como agregar uno, y luego al lado derecho de nuestras herramientas del desarrollador podemos ver la secci贸n con el nombre
`Call Stack` donde veremos nuestras funciones y como se va actualizando a medida que vamos avanzando en la ejecuci贸n.

<img
  src="https://res.cloudinary.com/dtg6xzrhh/image/upload/v1618603900/miguelcast.dev/Captura_de_Pantalla_2021-04-16_a_la_s_3.09.08_p._m._mdmadk.png"
  alt="call stack dev tools"
  loading="lazy"
/>

Si quiere profundizar m谩s en este concepto, te recomiendo el video del canal de Youtube La Cocina del C贸digo llamado
[1. La PILA DE EJECUCIN (Call Stack) de JAVASCRIPT | JS en ESPAOL](https://youtu.be/ygA5U7Wgsg8).
